/// <reference types="node" />
/// <reference types="node" />
import type { Client, ClientOptions as DiscordJsClientOptions } from 'discord.js';
import { Message, SessionObject } from './Util';
import { MainUtil as PrimaryIpc } from './ipc/MainUtil';
import { ClusterManager } from './ClusterManager';
import { ClusterSettings } from 'node:cluster';
import EventEmitter from 'node:events';
/**
 * Options to control Indomitable behavior
 */
export interface IndomitableOptions {
    clusterCount?: number | 'auto';
    shardCount?: number | 'auto';
    clientOptions?: DiscordJsClientOptions;
    clusterSettings?: ClusterSettings;
    ipcTimeout?: number;
    spawnTimeout?: number;
    spawnDelay?: number;
    autoRestart?: boolean;
    waitForReady?: boolean;
    client: typeof Client;
    token: string;
}
export interface ShardEventData {
    clusterId: number;
    shardId?: number;
    replayed?: number;
    event?: CloseEvent;
}
export declare interface Indomitable {
    /**
     * Emitted when data useful for debugging is produced
     * @eventProperty
     */
    on(event: 'debug', listener: (message: string) => void): this;
    /**
     * Emmited when an IPC message is recieved
     * @eventProperty
     */
    on(event: 'message', listener: (message: Message | unknown) => void): this;
    /**
     * Emitted when an error occurs
     * @eventProperty
     */
    on(event: 'error', listener: (error: unknown) => void): this;
    /**
     * Emitted when a new worker process is forked
     * @eventProperty
     */
    on(event: 'workerFork', listener: (cluster: ClusterManager) => void): this;
    /**
     * Emitted when a worker process is ready
     * @eventProperty
     */
    on(event: 'workerReady', listener: (cluster: ClusterManager) => void): this;
    /**
     * Emitted when a worker process exits
     * @eventProperty
     */
    on(event: 'workerExit', listener: (code: number | null, signal: string | null, cluster: ClusterManager) => void): this;
    /**
     * Emitted when a Discord.js shard is ready
     * @eventProperty
     */
    on(event: 'shardReady', listener: (event: ShardEventData) => void): this;
    /**
     * Emitted when a Discord.js shard is reconnecting
     * @eventProperty
     */
    on(event: 'shardReconnect', listener: (event: ShardEventData) => void): this;
    /**
     * Emitted when a Discord.js shard resumes
     * @eventProperty
     */
    on(event: 'shardResume', listener: (event: ShardEventData) => void): this;
    /**
     * Emitted when a Discord.js shard disconnects
     * @eventProperty
     */
    on(event: 'shardDisconnect', listener: (event: ShardEventData) => void): this;
    once(event: 'debug', listener: (message: string) => void): this;
    once(event: 'message', listener: (message: Message | unknown) => void): this;
    once(event: 'error', listener: (error: unknown) => void): this;
    once(event: 'workerFork', listener: (cluster: ClusterManager) => void): this;
    once(event: 'workerReady', listener: (cluster: ClusterManager) => void): this;
    once(event: 'workerExit', listener: (code: number | null, signal: string | null, cluster: ClusterManager) => void): this;
    once(event: 'shardReady', listener: (event: ShardEventData) => void): this;
    once(event: 'shardReconnect', listener: (event: ShardEventData) => void): this;
    once(event: 'shardResume', listener: (event: ShardEventData) => void): this;
    once(event: 'shardDisconnect', listener: (event: ShardEventData) => void): this;
    off(event: 'debug', listener: (message: string) => void): this;
    off(event: 'message', listener: (message: Message | unknown) => void): this;
    off(event: 'error', listener: (error: unknown) => void): this;
    off(event: 'workerFork', listener: (cluster: ClusterManager) => void): this;
    off(event: 'workerReady', listener: (cluster: ClusterManager) => void): this;
    off(event: 'workerExit', listener: (code: number | null, signal: string | null, cluster: ClusterManager) => void): this;
    off(event: 'shardReady', listener: (event: ShardEventData) => void): this;
    off(event: 'shardReconnect', listener: (event: ShardEventData) => void): this;
    off(event: 'shardResume', listener: (event: ShardEventData) => void): this;
    off(event: 'shardDisconnect', listener: (event: ShardEventData) => void): this;
}
/**
 * The main Indomitable class, exposing all functionality.
 */
export declare class Indomitable extends EventEmitter {
    clusterCount: number | 'auto';
    shardCount: number | 'auto';
    cachedSession?: SessionObject;
    readonly clientOptions: DiscordJsClientOptions;
    readonly clusterSettings: ClusterSettings;
    readonly ipcTimeout: number;
    readonly spawnTimeout: number;
    readonly spawnDelay: number;
    readonly autoRestart: boolean;
    readonly waitForReady: boolean;
    readonly client: typeof Client;
    readonly clusters?: Map<number, ClusterManager>;
    readonly ipc?: PrimaryIpc;
    private readonly spawnQueue?;
    private readonly token;
    private busy?;
    /**
     * @param [options.clusterCount=auto] The amount of clusters to spawn. Expects a number or 'auto'
     * @param [options.shardCount=auto] The number of shards to create. Expects a number or 'auto'
     * @param [options.clientOptions] Options for the Discord.js client
     * @param [options.clusterSettings] Options for the forked process
     * @param [options.ipcTimeout] Time to wait before reporting a failed IPC connection
     * @param [options.spawnTimeout] Time to wait before reporting a failed child process spawn
     * @param [options.spawnDelay] Time to wait before spawing another child process
     * @param [options.autoRestart] Whether to automatically restart shards that have been killed unintentionally
     * @param [options.waitForReady] Whether to wait for clusters to be ready before spawning a new one
     * @param [options.client] A Discord.js client class or a modified Discord.js client class
     * @param options.token Discord bot token
     */
    constructor(options: IndomitableOptions);
    /**
     * Gets how many clusters are waiting to be spawned
     * @returns Number of clusters in queue
     */
    get inSpawnQueueCount(): number;
    /**
     * Gets the current session info of the bot token Indomitable currently handles
     * @returns Session Info
     */
    fetchSessions(): Promise<SessionObject>;
    /**
     * Spawn a new ShardClient if this instance is a child process, or start a new cluster and IPC server if this instance is the primary process
     * @returns A promise that resolves to void
     */
    spawn(): Promise<void>;
    /**
     * Restart specified cluster if this instance is the primary process
     * @param clusterId Id of cluster to restart
     * @returns A promise that resolves to void
     */
    restart(clusterId: number): Promise<void>;
    /**
     * Restart all clusters if this instance is the primary process
     * @returns A promise that resolves to void
     */
    restartAll(): Promise<void>;
    /**
     * Adds a cluster to spawn queue
     * @internal
     */
    addToSpawnQueue(...clusters: ClusterManager[]): Promise<void> | undefined;
    /**
     * Adds a cluster to spawn queue
     * @internal
     */
    private processQueue;
}
//# sourceMappingURL=Indomitable.d.ts.map