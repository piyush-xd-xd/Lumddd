"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Main = void 0;
const crypto_1 = require("crypto");
const Util_1 = require("../Util");
class Main {
    cluster;
    promises;
    constructor(cluster) {
        this.cluster = cluster;
        this.promises = new Map();
    }
    get manager() {
        return this.cluster.manager;
    }
    get pending() {
        return this.promises.size;
    }
    flush(reason) {
        const error = new Error(reason);
        for (const promise of this.promises.values()) {
            clearTimeout(promise.timeout);
            promise.reject(error);
        }
        this.promises.clear();
    }
    send(transportable) {
        return new Promise((resolve, reject) => {
            if (!this.cluster.worker) {
                this.manager.emit(Util_1.LibraryEvents.DEBUG, `Tried to send message to cluster ${this.cluster.id} but this worker is yet to be available`);
                return resolve(undefined);
            }
            const repliable = transportable.repliable || false;
            const id = repliable ? (0, crypto_1.randomUUID)() : null;
            const data = {
                id,
                content: transportable.content,
                internal: true,
                type: Util_1.RawIpcMessageType.MESSAGE
            };
            this.cluster.worker.send(data);
            if (!id)
                return resolve(undefined);
            const timeout = setTimeout(() => {
                this.promises.delete(id);
                reject(new Error('This request timed out'));
            }, this.manager.ipcTimeout).unref();
            this.promises.set(id, { resolve, reject, timeout });
        });
    }
    async handle(data) {
        try {
            if (!data.internal)
                return this.manager.emit(Util_1.LibraryEvents.MESSAGE, data);
            if (data.type === Util_1.RawIpcMessageType.MESSAGE)
                return await this.message(data);
            if (data.type === Util_1.RawIpcMessageType.RESPONSE)
                return this.promise(data);
        }
        catch (error) {
            this.manager.emit(Util_1.LibraryEvents.ERROR, error);
        }
    }
    promise(data) {
        const id = data.id;
        const promise = this.promises.get(id);
        if (!promise)
            return;
        this.promises.delete(id);
        clearTimeout(promise.timeout);
        if (data.content?.internal && data.content?.error) {
            const error = new Error(data.content.reason || 'Unknown error reason');
            error.stack = data.content.stack;
            error.name = data.content.name;
            return promise.reject(error);
        }
        promise.resolve(data.content);
    }
    async message(data) {
        const reply = (content) => {
            if (!data.id)
                return;
            const response = {
                id: data.id,
                content,
                internal: true,
                type: Util_1.RawIpcMessageType.RESPONSE
            };
            this.cluster.worker.send(response);
        };
        const message = {
            repliable: !!data.id,
            content: data.content,
            reply
        };
        if (!message.content.internal)
            return this.manager.emit(Util_1.LibraryEvents.MESSAGE, message);
        // internal error handling
        try {
            const content = message.content;
            switch (content.op) {
                case Util_1.ClientEvents.READY: {
                    const cluster = this.manager.clusters.get(content.data.clusterId);
                    if (cluster) {
                        cluster.ready = true;
                        cluster.readyAt = Date.now();
                        if (cluster.tickReady)
                            cluster.tickReady();
                    }
                    break;
                }
                case Util_1.ClientEvents.PING: {
                    const end = process.hrtime.bigint().toString();
                    message.reply(end);
                    break;
                }
                case Util_1.ClientEvents.EVAL: {
                    // don't touch eval data, just forward it to clusters since this is already an instance of InternalEvent
                    const data = await this.manager.ipc.broadcast({
                        content,
                        repliable: true
                    });
                    message.reply(data);
                    break;
                }
                case Util_1.ClientEvents.SESSION_INFO: {
                    if (content.data.update || !this.manager.cachedSession)
                        this.manager.cachedSession = await this.manager.fetchSessions();
                    message.reply(this.manager.cachedSession);
                    break;
                }
                case Util_1.ClientEvents.RESTART:
                    await this.manager.restart(content.data.clusterId);
                    break;
                case Util_1.ClientEvents.RESTART_ALL:
                    await this.manager.restartAll();
                    break;
                default:
                    // shardReconect, shardResume etc
                    this.manager.emit(content.op, content.data);
            }
        }
        catch (error) {
            if (!message.repliable)
                throw error;
            message.reply({
                internal: true,
                error: true,
                name: error.name,
                reason: error.reason,
                stack: error.stack
            });
        }
    }
}
exports.Main = Main;
//# sourceMappingURL=Main.js.map