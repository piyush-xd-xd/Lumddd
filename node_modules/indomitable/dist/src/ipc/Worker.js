"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Worker = void 0;
const crypto_1 = require("crypto");
const Util_1 = require("../Util");
class Worker {
    shard;
    manager;
    promises;
    constructor(shard, manager) {
        this.shard = shard;
        this.manager = manager;
        this.promises = new Map();
        process.on('message', data => this.handle(data));
    }
    get pending() {
        return this.promises.size;
    }
    flush(reason) {
        const error = new Error(reason);
        for (const promise of this.promises.values()) {
            clearTimeout(promise.timeout);
            promise.reject(error);
        }
        this.promises.clear();
    }
    async ping() {
        const content = {
            op: Util_1.ClientEvents.PING,
            data: {},
            internal: true
        };
        const start = process.hrtime.bigint();
        const end = await this.send({ content, repliable: true });
        return Number(BigInt(end) - start);
    }
    send(transportable) {
        return new Promise((resolve, reject) => {
            const repliable = transportable.repliable || false;
            const id = repliable ? (0, crypto_1.randomUUID)() : null;
            const data = {
                id,
                content: transportable.content,
                internal: true,
                type: Util_1.RawIpcMessageType.MESSAGE
            };
            try {
                process.send(data);
            }
            catch (error) {
                return reject(error);
            }
            if (!id)
                return resolve(undefined);
            const timeout = setTimeout(() => {
                this.promises.delete(id);
                reject(new Error('This request timed out'));
            }, this.manager.ipcTimeout).unref();
            this.promises.set(id, { resolve, reject, timeout });
        });
    }
    handle(data) {
        try {
            if (!data.internal)
                return this.manager.emit(Util_1.LibraryEvents.MESSAGE, data);
            if (data.type === Util_1.RawIpcMessageType.MESSAGE)
                return this.message(data);
            if (data.type === Util_1.RawIpcMessageType.RESPONSE)
                return this.promise(data);
        }
        catch (error) {
            // most people handle client.on('error', () => {}) in discord.js since its mandatory, so we'll take advantage of it
            this.shard.client.emit(Util_1.LibraryEvents.ERROR, error);
        }
    }
    promise(data) {
        const id = data.id;
        const promise = this.promises.get(id);
        if (!promise)
            return;
        this.promises.delete(id);
        clearTimeout(promise.timeout);
        if (data.content?.internal && data.content?.error) {
            const error = new Error(data.content.reason || 'Unknown error reason');
            error.stack = data.content.stack;
            error.name = data.content.name;
            return promise.reject(error);
        }
        promise.resolve(data.content);
    }
    message(data) {
        const reply = (content) => {
            if (!data.id)
                return;
            const response = {
                id: data.id,
                content,
                internal: true,
                type: Util_1.RawIpcMessageType.RESPONSE
            };
            process.send(response);
        };
        const message = {
            repliable: !!data.id,
            content: data.content,
            reply
        };
        if (!message.content.internal)
            return this.shard.emit(Util_1.LibraryEvents.MESSAGE, message);
        try {
            const content = message.content;
            if (content.op === Util_1.ClientEvents.EVAL)
                // @ts-ignore -- needs to be accessed for broadcastEval
                message.reply(this.shard.client._eval(content.data));
        }
        catch (error) {
            if (!message.repliable)
                throw error;
            message.reply({
                internal: true,
                error: true,
                name: error.name,
                reason: error.reason,
                stack: error.stack
            });
        }
    }
}
exports.Worker = Worker;
//# sourceMappingURL=Worker.js.map