"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Primary = void 0;
const net_ipc_1 = require("net-ipc");
const Util_1 = require("../Util");
class Primary {
    manager;
    server;
    constructor(manager) {
        this.manager = manager;
        this.server = new net_ipc_1.Server({ ...{ path: 'indomitable' }, ...(this.manager.ipcOptions.primary || {}) })
            .on('ready', (address) => this.manager.emit(Util_1.LibraryEvents.DEBUG, `Indomitable's IPC server is now ready, currently bound at address: ${address}`))
            .on('disconnect', (...args) => this.manager.emit(Util_1.LibraryEvents.DISCONNECT, ...args))
            .on('close', (...args) => this.manager.emit(Util_1.LibraryEvents.CLOSE, ...args))
            .on('connect', (connection, payload) => this.connect(connection, payload))
            .on('message', message => this.message(message))
            .on('request', (message, response) => this.message(message, response))
            .on('error', (...args) => {
            if (this.manager.listeners(Util_1.LibraryEvents.ERROR).length === 0)
                return;
            this.manager.emit(Util_1.LibraryEvents.ERROR, ...args);
        });
    }
    async send(id, transportable) {
        const cluster = this.manager.clusters.get(id);
        if (!cluster)
            throw new Error('This cluster is not yet ready / not yet in cache');
        const connection = this.manager.ipc.server.connections.find(connection => cluster.ipcId === connection.id);
        if (!connection)
            throw new Error(`The cluster ipcId didn\'t match any connection id. Current cluster ipcId: ${cluster.ipcId}`);
        const repliable = transportable.repliable ?? false;
        if (repliable) {
            const result = await connection.request(transportable, this.manager.ipcTimeout);
            if (result?.internal && result.error) {
                const error = new Error(result.reason || 'Unspecified reason');
                error.stack = result.stack;
                error.name = result.name;
                throw error;
            }
            return result;
        }
        return await connection.send(transportable);
    }
    async broadcast(transportable) {
        const repliable = transportable.repliable ?? false;
        if (repliable) {
            const results = await this.server.survey(transportable, this.manager.ipcTimeout);
            const rejected = results.find(result => result.status === 'rejected');
            if (rejected)
                throw new Error(rejected.reason || 'Unspecified reason');
            const values = results.map(result => result.value);
            const internalError = values.find(result => result.internal && result.error);
            if (internalError) {
                const error = new Error(internalError.reason || 'Unspecified reason');
                error.stack = internalError.stack;
                error.name = internalError.name;
                throw error;
            }
            return values;
        }
        return await Promise.all(this.server.connections.map(connection => connection
            .send(transportable)
            .catch((error) => this.server.emit(Util_1.LibraryEvents.ERROR, error))));
    }
    connect(connection, payload) {
        if (payload.internal) {
            const cluster = this.manager.clusters.get(Number(payload.clusterId));
            cluster.ipcId = connection.id;
            this.manager.emit(Util_1.LibraryEvents.DEBUG, `Cluster ${cluster.id} ipc is now connected. Assigned Id: ${cluster.ipcId}`);
        }
        setImmediate(() => this.manager.emit(Util_1.LibraryEvents.CONNECT, connection, payload)).unref();
    }
    async message(data, response) {
        try {
            const reply = response || (async () => undefined);
            const message = {
                reply,
                content: data.content,
                repliable: !!response,
            };
            // internal events should not be emitted to end user
            if (message.content.internal) {
                // internal error handling
                try {
                    const content = message.content;
                    switch (content.op) {
                        case Util_1.ClientEvents.READY: {
                            const cluster = this.manager.clusters.get(content.data.clusterId);
                            if (cluster?.tickReady)
                                cluster.tickReady();
                            break;
                        }
                        case Util_1.ClientEvents.EVAL: {
                            // don't touch eval data, just forward it to clusters since this is already an instance of InternalEvent
                            const data = await this.broadcast({
                                content,
                                repliable: true
                            });
                            await message.reply(data);
                            break;
                        }
                        case Util_1.ClientEvents.SESSION_INFO: {
                            if (content.data.update || !this.manager.cachedSession)
                                this.manager.cachedSession = await this.manager.fetchSessions();
                            await message.reply(this.manager.cachedSession);
                            break;
                        }
                        case Util_1.ClientEvents.RESTART:
                            await this.manager.restart(content.data.clusterId);
                            break;
                        case Util_1.ClientEvents.RESTART_ALL:
                            await this.manager.restartAll();
                            break;
                        default:
                            // shardReconect, shardResume etc
                            this.manager.emit(content.op, content.data);
                    }
                }
                catch (error) {
                    if (!message.repliable)
                        throw error;
                    const internalError = {
                        internal: true,
                        error: true,
                        name: error.name,
                        reason: error.reason,
                        stack: error.stack
                    };
                    await message.reply(internalError);
                }
                return;
            }
            this.manager.emit(Util_1.LibraryEvents.MESSAGE, message);
        }
        catch (error) {
            this.manager.emit(Util_1.LibraryEvents.ERROR, error);
        }
    }
}
exports.Primary = Primary;
//# sourceMappingURL=Primary.js.map