"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClusterManager = void 0;
const node_cluster_1 = __importDefault(require("node:cluster"));
const Main_1 = require("./ipc/Main");
const Util_1 = require("./Util");
/**
 * A class to manage a cluster
 */
class ClusterManager {
    manager;
    id;
    shards;
    ipc;
    started;
    ipcId;
    worker;
    tickReady;
    ready;
    readyAt;
    /**
     * @param options.id Cluster ID
     * @param options.shards An array of numbers representing the shards that this cluster controls
     * @param options.manager Indomitable instance that spawned this cluster
     */
    constructor(options) {
        this.manager = options.manager;
        this.id = options.id;
        this.shards = options.shards;
        this.ipc = new Main_1.Main(this);
        this.started = false;
        this.worker = undefined;
        this.tickReady = undefined;
        this.ready = false;
        this.readyAt = -1;
    }
    /**
     * Destroy associated worker process
     * @param signal Process exit signal
     */
    destroy(signal = 'SIGTERM') {
        this.worker?.kill(signal);
        this.cleanup(0, signal);
    }
    /**
     * Respawn associated worker process
     * @param delay Time to wait before restarting worker process
     */
    async respawn(delay = this.manager.spawnDelay) {
        this.manager.emit(Util_1.LibraryEvents.DEBUG, `Restarting Cluster ${this.id} containing [ ${this.shards.join(', ')} ] shard(s)...`);
        this.destroy('SIGKILL');
        await (0, Util_1.Delay)(delay);
        await this.spawn();
    }
    /**
     * Spawn a worker process
     */
    async spawn() {
        this.manager.emit(Util_1.LibraryEvents.DEBUG, `Spawning Cluster ${this.id} containing [ ${this.shards.join(', ')} ] shard(s)...`);
        this.worker = node_cluster_1.default.fork({
            SHARDS: this.shards.join(' '),
            SHARDS_TOTAL: this.manager.shardCount.toString(),
            CLUSTER: this.id.toString(),
            CLUSTER_TOTAL: this.manager.clusterCount.toString(),
            ...process.env
        });
        this.worker
            .on('message', message => this.ipc.handle(message))
            .on('error', error => this.manager.emit(Util_1.LibraryEvents.ERROR, error))
            .once('exit', (code, signal) => {
            this.cleanup(code, signal);
            if (!this.manager.autoRestart)
                return;
            this.manager.addToSpawnQueue(this);
        });
        this.manager.emit(Util_1.LibraryEvents.WORKER_FORK, this);
        if (this.manager.waitForReady)
            await this.wait();
        this.manager.emit(Util_1.LibraryEvents.DEBUG, `Succesfully spawned Cluster ${this.id} containing [ ${this.shards.join(', ')} ] shard(s)! | Waited for cluster ready? ${this.manager.waitForReady}`);
        this.manager.emit(Util_1.LibraryEvents.WORKER_READY, this);
        await (0, Util_1.Delay)(this.manager.spawnDelay);
        if (!this.started)
            this.started = true;
    }
    /**
     * Remove all listeners on attached worker process and free from memory
     */
    cleanup(code, signal) {
        this.ipc.flush(`Cluster exited with close code ${code || 'unknown'} signal ${signal || 'unknown'}`);
        this.worker?.removeAllListeners();
        this.worker = undefined;
        this.ready = false;
        this.readyAt = -1;
        if (!this.worker)
            return;
        this.manager.emit(Util_1.LibraryEvents.DEBUG, `Cluster ${this.id} exited with close code ${code || 'unknown'} signal ${signal || 'unknown'}`);
        this.manager.emit(Util_1.LibraryEvents.WORKER_EXIT, code, signal, this);
    }
    /**
     * Waits for this cluster to be ready
     * @returns A promise that resolves to void
     * @internal
     */
    wait() {
        return new Promise((resolve, reject) => {
            const ms = this.manager.spawnTimeout * this.shards.length;
            const timeout = setTimeout(() => {
                this.tickReady = undefined;
                this.destroy();
                reject(new Error(`Cluster ${this.id} did not get ready in ${Math.round(ms / 1000)} seconds`));
            }, ms);
            this.tickReady = () => {
                clearTimeout(timeout);
                resolve();
            };
        });
    }
}
exports.ClusterManager = ClusterManager;
//# sourceMappingURL=ClusterManager.js.map