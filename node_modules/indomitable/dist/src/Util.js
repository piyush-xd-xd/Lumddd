"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Delay = exports.Chunk = exports.FetchSessions = exports.Fetch = exports.RawIpcMessageType = exports.LibraryEvents = exports.ClientEvents = void 0;
const node_https_1 = __importDefault(require("node:https"));
/**
 * Events for internal use
 */
var ClientEvents;
(function (ClientEvents) {
    ClientEvents["EVAL"] = "eval";
    ClientEvents["RESTART"] = "restart";
    ClientEvents["RESTART_ALL"] = "restartAll";
    ClientEvents["SESSION_INFO"] = "sessionInfo";
    ClientEvents["READY"] = "ready";
    ClientEvents["PING"] = "ping";
    ClientEvents["SHARD_READY"] = "shardReady";
    ClientEvents["SHARD_RECONNECT"] = "shardReconnect";
    ClientEvents["SHARD_RESUME"] = "shardResume";
    ClientEvents["SHARD_DISCONNECT"] = "shardDisconnect";
})(ClientEvents = exports.ClientEvents || (exports.ClientEvents = {}));
/**
 * Events emitted by Indomitable
 */
var LibraryEvents;
(function (LibraryEvents) {
    LibraryEvents["DEBUG"] = "debug";
    LibraryEvents["CONNECT"] = "connect";
    LibraryEvents["DISCONNECT"] = "disconnect";
    LibraryEvents["CLOSE"] = "close";
    LibraryEvents["MESSAGE"] = "message";
    LibraryEvents["STATUS"] = "status";
    LibraryEvents["ERROR"] = "error";
    LibraryEvents["WORKER_FORK"] = "workerFork";
    LibraryEvents["WORKER_READY"] = "workerReady";
    LibraryEvents["WORKER_EXIT"] = "workerExit";
    LibraryEvents["SHARD_READY"] = "shardReady";
    LibraryEvents["SHARD_RECONNECT"] = "shardReconnect";
    LibraryEvents["SHARD_RESUME"] = "shardResume";
    LibraryEvents["SHARD_DISCONNECT"] = "shardDisconnect";
})(LibraryEvents = exports.LibraryEvents || (exports.LibraryEvents = {}));
/**
 * Type for raw ipc message
 */
var RawIpcMessageType;
(function (RawIpcMessageType) {
    RawIpcMessageType["MESSAGE"] = "message";
    RawIpcMessageType["RESPONSE"] = "response";
})(RawIpcMessageType = exports.RawIpcMessageType || (exports.RawIpcMessageType = {}));
/**
 * Wrapper function for fetching data using HTTP
 * @param url URL of resource to fetch
 * @param options RequestOptions to modify behavior
 * @returns A promise containing data fetched, or an error
 */
function Fetch(url, options) {
    return new Promise((resolve, reject) => {
        const request = node_https_1.default.request(url, options, response => {
            const chunks = [];
            response.on('data', chunk => chunks.push(chunk));
            response.on('error', reject);
            response.on('end', () => {
                const code = response.statusCode ?? 500;
                const body = chunks.join('');
                if (code >= 200 && code <= 299)
                    resolve(body);
                else
                    reject(new Error(`Response received is not ok, Status Code: ${response.statusCode}, body: ${body}`));
            });
        });
        request.on('error', reject);
        request.end();
    });
}
exports.Fetch = Fetch;
/**
 * Fetch sessions from discord
 * @param token Bot token
 * @returns A promise containing a session object
 */
async function FetchSessions(token) {
    const url = new URL('https://discord.com/api/v10/gateway/bot');
    const data = await Fetch(url, {
        method: 'GET',
        headers: { authorization: `Bot ${token}` }
    });
    return JSON.parse(data);
}
exports.FetchSessions = FetchSessions;
/**
 * Modify an array to contain a the specified amount of chunks
 * @param original An array of data
 * @param chunks The amount of chunks to transform into
 * @returns A modified array
 */
function Chunk(original, chunks) {
    const array = [];
    for (let i = 0; i < original.length; i += chunks)
        array.push(original.slice(i, i + chunks));
    return array;
}
exports.Chunk = Chunk;
/**
 * Wait for a specific amount of time (timeout)
 * @param ms Time to wait in milliseconds
 * @returns A promise that resolves in x seconds
 */
function Delay(ms) {
    return new Promise(resolve => setTimeout(() => resolve(), ms).unref());
}
exports.Delay = Delay;
//# sourceMappingURL=Util.js.map