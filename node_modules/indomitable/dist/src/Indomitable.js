"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Indomitable = void 0;
const Util_1 = require("./Util");
const ShardClient_1 = require("./client/ShardClient");
const MainUtil_1 = require("./ipc/MainUtil");
const ClusterManager_1 = require("./ClusterManager");
const node_cluster_1 = __importDefault(require("node:cluster"));
const node_events_1 = __importDefault(require("node:events"));
const node_os_1 = __importDefault(require("node:os"));
/**
 * The main Indomitable class, exposing all functionality.
 */
class Indomitable extends node_events_1.default {
    clusterCount;
    shardCount;
    cachedSession;
    clientOptions;
    clusterSettings;
    ipcTimeout;
    spawnTimeout;
    spawnDelay;
    autoRestart;
    waitForReady;
    client;
    clusters;
    ipc;
    spawnQueue;
    token;
    busy;
    /**
     * @param [options.clusterCount=auto] The amount of clusters to spawn. Expects a number or 'auto'
     * @param [options.shardCount=auto] The number of shards to create. Expects a number or 'auto'
     * @param [options.clientOptions] Options for the Discord.js client
     * @param [options.clusterSettings] Options for the forked process
     * @param [options.ipcTimeout] Time to wait before reporting a failed IPC connection
     * @param [options.spawnTimeout] Time to wait before reporting a failed child process spawn
     * @param [options.spawnDelay] Time to wait before spawing another child process
     * @param [options.autoRestart] Whether to automatically restart shards that have been killed unintentionally
     * @param [options.waitForReady] Whether to wait for clusters to be ready before spawning a new one
     * @param [options.client] A Discord.js client class or a modified Discord.js client class
     * @param options.token Discord bot token
     */
    constructor(options) {
        super();
        this.clusterCount = options.clusterCount || 'auto';
        this.shardCount = options.shardCount || 'auto';
        this.clientOptions = options.clientOptions || { intents: [1 << 0] };
        this.clusterSettings = options.clusterSettings || {};
        this.ipcTimeout = options.ipcTimeout ?? 30000;
        this.spawnTimeout = options.spawnTimeout ?? 60000;
        this.spawnDelay = options.spawnDelay ?? 5000;
        this.autoRestart = options.autoRestart ?? false;
        this.waitForReady = options.waitForReady ?? true;
        this.client = options.client;
        this.token = options.token;
        if (!node_cluster_1.default.isPrimary)
            return;
        this.clusters = new Map();
        this.ipc = new MainUtil_1.MainUtil(this);
        this.spawnQueue = [];
        this.busy = false;
        this.cachedSession = undefined;
    }
    /**
     * Gets how many clusters are waiting to be spawned
     * @returns Number of clusters in queue
     */
    get inSpawnQueueCount() {
        if (!node_cluster_1.default.isPrimary)
            return 0;
        return this.spawnQueue.length;
    }
    /**
     * Gets the current session info of the bot token Indomitable currently handles
     * @returns Session Info
     */
    fetchSessions() {
        return (0, Util_1.FetchSessions)(this.token);
    }
    /**
     * Spawn a new ShardClient if this instance is a child process, or start a new cluster and IPC server if this instance is the primary process
     * @returns A promise that resolves to void
     */
    async spawn() {
        if (!node_cluster_1.default.isPrimary) {
            const shardClient = new ShardClient_1.ShardClient(this);
            await shardClient.start(this.token);
            return;
        }
        if (typeof this.clusterCount !== 'number')
            this.clusterCount = node_os_1.default.cpus().length;
        if (typeof this.shardCount !== 'number') {
            this.cachedSession = await this.fetchSessions();
            this.shardCount = this.cachedSession.shards;
        }
        if (this.shardCount < this.clusterCount)
            this.clusterCount = this.shardCount;
        this.emit(Util_1.LibraryEvents.DEBUG, `Starting ${this.shardCount} websocket shards across ${this.clusterCount} clusters`);
        const shards = [...Array(this.shardCount).keys()];
        const chunks = (0, Util_1.Chunk)(shards, Math.round(this.shardCount / this.clusterCount));
        node_cluster_1.default.setupPrimary({ ...{ serialization: 'json' }, ...this.clusterSettings });
        for (let id = 0; id < this.clusterCount; id++) {
            const chunk = chunks.shift();
            const cluster = new ClusterManager_1.ClusterManager({ id, shards: chunk, manager: this });
            this.clusters.set(id, cluster);
        }
        await this.addToSpawnQueue(...this.clusters.values());
    }
    /**
     * Restart specified cluster if this instance is the primary process
     * @param clusterId Id of cluster to restart
     * @returns A promise that resolves to void
     */
    async restart(clusterId) {
        if (!node_cluster_1.default.isPrimary)
            return;
        const cluster = this.clusters.get(clusterId);
        if (!cluster)
            throw new Error(`Invalid clusterId, or a cluster with this id doesn\'t exist, received id ${clusterId}`);
        await this.addToSpawnQueue(cluster);
    }
    /**
     * Restart all clusters if this instance is the primary process
     * @returns A promise that resolves to void
     */
    async restartAll() {
        if (!node_cluster_1.default.isPrimary)
            return;
        this.emit(Util_1.LibraryEvents.DEBUG, `Restarting ${this.clusters.size} clusters sequentially...`);
        await this.addToSpawnQueue(...this.clusters.values());
    }
    /**
     * Adds a cluster to spawn queue
     * @internal
     */
    addToSpawnQueue(...clusters) {
        if (!node_cluster_1.default.isPrimary)
            return;
        this.spawnQueue.push(...clusters);
        return this.processQueue();
    }
    /**
     * Adds a cluster to spawn queue
     * @internal
     */
    async processQueue() {
        if (this.busy || !this.spawnQueue.length)
            return;
        this.busy = true;
        this.emit(Util_1.LibraryEvents.DEBUG, `Processing spawn queue with ${this.spawnQueue.length} clusters waiting to be spawned....`);
        let cluster;
        while (this.spawnQueue.length > 0) {
            try {
                cluster = this.spawnQueue.shift();
                if (cluster.started)
                    await cluster.respawn();
                else
                    await cluster.spawn();
            }
            catch (error) {
                this.emit(Util_1.LibraryEvents.ERROR, error);
                if (cluster && this.autoRestart) {
                    this.emit(Util_1.LibraryEvents.DEBUG, `Failed to spawn Cluster ${cluster.id} containing [ ${cluster.shards.join(', ')} ] shard(s). Requeuing...`);
                    if (!this.spawnQueue.includes(cluster))
                        this.spawnQueue.push(cluster);
                }
            }
        }
        this.busy = false;
        this.emit(Util_1.LibraryEvents.DEBUG, 'Cluster Queue Empty! Clusters done booting up');
    }
}
exports.Indomitable = Indomitable;
//# sourceMappingURL=Indomitable.js.map